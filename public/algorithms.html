<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Алгоритми програмування — Вивчення основ з SkillUpCoding</title>
    <meta
      name="description"
      content="Опануйте алгоритми програмування з SkillUpCoding. Навчайтеся основам сортування, пошуку (лінійного, бінарного), стека, черги, BFS, Dijkstra, і дізнайтеся про часову складність алгоритмів."
    />
    <meta
      name="keywords"
      content="алгоритми, сортування, бінарний пошук, BFS, Dijkstra, стеки, черги, часова складність, SkillUpCoding"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" href="img/star-logo.ico" type="image/x-icon" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/form.js" defer></script>
  </head>

  <body>
    <header>
      <div class="wrapper">
        <a href="index.html" class="logo">SkillUpCoding</a>
        <nav id="desktop-menu" class="desktop-menu">
          <ul>
            <li><a href="index.html">Головна</a></li>
            <li><a href="snippets.html">Snippets</a></li>
            <li><a href="algorithms.html" class="active">Алгоритми</a></li>
            <li><a href="html-css.html">HTML/CSS</a></li>
            <li><a href="javascript.html">JavaScript</a></li>
            <li><a href="python.html">Python</a></li>
            <li><a href="csharp.html">C#</a></li>
            <li class="auth-buttons-desktop">
              <button id="sign-in-button" class="nav-btn">Sign In</button>
              <button id="sign-up-button" class="nav-btn">Sign Up</button>
              <button id="profile-button" class="nav-btn" style="display: none">
                Профіль
              </button>
            </li>
          </ul>
        </nav>
        <div id="menu-icon" class="menu-icon">&#9776;</div>
      </div>
    </header>

    <div id="offcanvas-menu" class="offcanvas-menu">
      <div class="offcanvas-header">
        <span id="close-menu" class="close-btn">&times;</span>
        <h2>Меню</h2>
      </div>
      <ul>
        <li><a href="index.html">Головна</a></li>
        <li><a href="snippets.html">Snippets</a></li>
        <li><a href="algorithms.html" class="active">Алгоритми</a></li>
        <li><a href="html-css.html">HTML/CSS</a></li>
        <li><a href="javascript.html">JavaScript</a></li>
        <li><a href="python.html">Python</a></li>
        <li><a href="csharp.html">C#</a></li>
        <li class="auth-buttons-mobile">
          <button id="sign-in-button-m" class="nav-btn">Sign In</button>
          <button id="sign-up-button-m" class="nav-btn">Sign Up</button>
          <button id="profile-button-m" class="nav-btn" style="display: none">
            Профіль
          </button>
        </li>
      </ul>
    </div>

    <section id="algorithms" class="main-page-one">
      <div class="wrapper">
        <div class="main-page-text-container">
          <div class="section-content">
            <img
              src="img/algorithms.jpg"
              alt="Ілюстрація алгоритмів"
              class="image-container"
            />
            <div class="text-content">
              <h1 class="main-page-title">Алгоритми</h1>
              <p class="main-page-descr">
                Алгоритми — це фундамент програмування. Вони являють собою
                послідовність дій або інструкцій, необхідних для розв’язання
                певної задачі. Будь-яка програма, від простого калькулятора до
                складних систем штучного інтелекту, покладається на алгоритми.
              </p>
              <p class="main-page-descr">
                Наприклад, у повсякденному житті &laquo;алгоритмом&raquo; може
                бути рецепт приготування страви: ви виконуєте кроки в певному
                порядку, щоб отримати бажаний результат. У програмуванні те
                саме: алгоритм визначає точну послідовність операцій, які
                виконує програма.
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section
      id="algorithms-intro"
      class="main-page section background-container"
    >
      <div class="wrapper">
        <div class="main-page-text-container">
          <div class="section-content">
            <div class="text-content-container">
              <h2 class="main-page-subtitle">Вступ до алгоритмів</h2>

              <h3 class="main-page-subsubtitle">Що таке алгоритм?</h3>
              <p class="main-page-descr">
                Алгоритм — це <strong>набір інструкцій</strong> чи правил, які
                крок за кроком описують, як досягти конкретної мети або
                розв’язати задачу. У контексті програмування алгоритми лежать в
                основі будь-якої програми. Якщо ви розумієте, як працюють
                алгоритми, то зможете краще:
              </p>
              <ul class="main-page-list">
                <li>
                  Оптимізувати ваш код та підвищувати його продуктивність;
                </li>
                <li>
                  Обирати відповідні структури даних і способи пошуку чи
                  сортування;
                </li>
                <li>
                  Легше розуміти логіку, що стоїть за будь-яким складним
                  програмним рішенням.
                </li>
              </ul>
              <p class="main-page-descr">
                Крім того, алгоритми — це універсальний засіб вирішення завдань
                у самих різних сферах, не тільки в програмуванні. Наприклад,
                кожен рецепт у кулінарії — це теж своєрідний алгоритм. У
                комп’ютерних науках ми формалізуємо ці набори кроків, щоб
                комп’ютер міг їх виконувати. Важливо зазначити, що алгоритм має
                бути <strong>точним</strong> і <strong>скінченним</strong>
                — тобто передбачати всі кроки й гарантувати завершення. Також
                алгоритми не обов’язково мають бути &laquo;програмними&raquo; –
                у побуті ми часто виконуємо певні процедури, які можна описати у
                вигляді алгоритму (згадайте хоча б ранкову рутину чи алгоритм
                дій при евакуації).
              </p>

              <h3 class="main-page-subsubtitle">Чому алгоритми важливі?</h3>
              <p class="main-page-descr">
                Ефективний алгоритм означає, що програма виконується швидше, з
                меншим споживанням пам’яті та ресурсів. Чим кращий алгоритм,
                тим:
              </p>
              <ul class="main-page-list">
                <li>
                  Менше часу виконання (часова складність нижча — наприклад,
                  O(n), O(log n) замість O(n^2));
                </li>
                <li>Краще масштабування при збільшенні обсягів даних;</li>
                <li>
                  Сприятливіший користувацький досвід (менше затримок, швидкі
                  відповіді).
                </li>
              </ul>
              <p class="main-page-descr">
                Іншими словами, розуміння алгоритмів допомагає обирати
                оптимальні підходи. Якщо в нас величезні масиви даних, алгоритм
                із O(n^2) може бути надто повільним, а алгоритм із O(n log n) —
                цілком прийнятним. До того ж, у реальних проєктах часто виникає
                потреба обробляти мільйони записів, і тоді різниця між O(n^2) та
                O(n log n) стає вирішальною. Висока продуктивність має значення
                не тільки для економії обчислювальних ресурсів, а й для
                зручності користувачів: швидка відповідь системи часто є
                ключовим фактором у формуванні позитивного враження про ваш
                продукт чи сервіс.
              </p>

              <h2 class="main-page-subsubtitle">Часова складність (Big O)</h2>
              <p class="main-page-descr">
                <strong>Часова складність</strong> визначає, як швидко зростає
                кількість операцій при збільшенні розміру вхідних даних. Часто
                використовують нотацію <em>Big O</em>:
              </p>
              <ul class="main-page-list">
                <li>
                  <strong>O(1)</strong>: час виконання не залежить від n
                  (розміру даних);
                </li>
                <li>
                  <strong>O(log n)</strong>: логарифмічна складність (бінарний
                  пошук);
                </li>
                <li><strong>O(n)</strong>: лінійна (лінійний пошук);</li>
                <li>
                  <strong>O(n log n)</strong>: наприклад, багато алгоритмів
                  сортування (швидке, злиття);
                </li>
                <li>
                  <strong>O(n^2)</strong>: бульбашкове сортування, сортування
                  вставками тощо.
                </li>
              </ul>
              <p class="main-page-descr">
                Знання нотації Big O дає змогу швидше оцінити, наскільки
                алгоритм підходить у певній ситуації. Наприклад, якщо вам
                кажуть: &laquo;Алгоритм має O(log n)&raquo;, ви одразу
                розумієте, що він дуже ефективний на великих обсягах даних, на
                відміну від O(n) чи O(n^2). Слід зауважити, що є навіть вищі
                складності — O(n^3) і більше — які зазвичай у реальних задачах
                застосовують лише за крайньої потреби. Також іноді зустрічають
                складності на кшталт O(2^n), які зазвичай свідчать про
                експоненційну &laquo;дороговартісність&raquo; обчислень, тож у
                практичних застосунках прагнуть уникати таких алгоритмів або
                шукати евристичні методи.
              </p>

              <h2 class="main-page-subsubtitle">Алгоритми пошуку</h2>

              <h3 class="main-page-subsubtitle">Лінійний пошук</h3>
              <p class="main-page-descr">
                Перевіряємо кожен елемент послідовно, поки не знайдемо потрібне
                значення або не дійдемо до кінця. Часова складність: O(n).
                Лінійний пошук простий, але на великих масивах може бути
                неефективним, якщо шуканий елемент розташований у кінці або його
                немає взагалі. Проте це все одно корисний базовий алгоритм,
                особливо коли дані не відсортовані або коли обсяг даних відносно
                невеликий.
              </p>
              <p class="main-page-descr">
                Наприклад, якщо у вас є список студентів у випадковому порядку і
                ви шукаєте конкретне ім'я, лінійний пошук просто порівнюватиме
                це ім'я із кожним у списку. Це простий у реалізації підхід, але
                кількість порівнянь може бути великою: у гіршому випадку треба
                переглянути всі елементи, що й дає O(n).
              </p>

              <h3 class="main-page-subsubtitle">Бінарний пошук</h3>
              <p class="main-page-descr">
                Ефективний для <strong>відсортованих</strong> структур даних.
                Послідовно ділимо масив навпіл і шукаємо, в якій половині може
                бути елемент. Часова складність: <strong>O(log n)</strong>.
                Наприклад, якщо масив з 1024 елементів, то бінарний пошук знайде
                потрібне значення максимум за 10 кроків (log2(1024) = 10).
                Завдяки цьому бінарний пошук значно швидший на великих масивах,
                але вимагає, щоб дані були відсортовані наперед.
              </p>
              <p class="main-page-descr">
                Якщо ж дані постійно змінюються й упорядкування порушується,
                може бути вигідніше застосовувати інші методи або мати
                структуру, яка швидко підтримує відсортованість (наприклад,
                дерева пошуку). Бінарний пошук є одним із найкращих прикладів
                алгоритму з логарифмічною складністю, який часто згадують, коли
                говорять про ефективність та Big O.
              </p>

              <h2 class="main-page-subsubtitle">
                Структури даних: Стек і Черга
              </h2>
              <p class="main-page-descr">
                Алгоритми часто використовують додаткові структури даних, щоби
                впорядкувати обчислювальні кроки. Найважливіші серед них —
                <strong>стек</strong> і <strong>черга</strong>.
              </p>
              <ul class="main-page-list">
                <li>
                  <strong>Стек</strong> (Stack): працює за принципом
                  <em>LIFO</em>
                  (Last In — First Out). Останній елемент, що
                  &laquo;зайшов&raquo;, першим &laquo;виходить&raquo;. Аналогія:
                  стопка тарілок. Коли ви кладете тарілку зверху, вона ж піде
                  першою для використання.
                </li>
                <li>
                  <strong>Черга</strong> (Queue): працює за принципом
                  <em>FIFO</em>
                  (First In — First Out). Перший, хто &laquo;зайшов&raquo;,
                  виходить першим. Аналогія: черга в супермаркеті. Черги часто
                  застосовуються у BFS (пошук у ширину) й у різних системах
                  обробки завдань, де головне — порядок надходження.
                </li>
              </ul>
              <p class="main-page-descr">
                Стек і черга — фундаментальні структури, які допомагають
                реалізовувати деякі алгоритми легко й природно. Наприклад,
                <em>стек</em> необхідний для організації викликів функцій (у
                багатьох мовах є &laquo;call stack&raquo;), а <em>черга</em> —
                для асинхронних черг повідомлень у різних системах. Коли
                розумієш ці дві базові структури, легше освоювати складніші
                (наприклад, пріоритетні черги, двосторонні черги тощо).
              </p>

              <h2 class="main-page-subsubtitle">Сортування</h2>
              <p class="main-page-descr">
                Сортування — це алгоритми впорядкування даних за певним
                критерієм (наприклад, за зростанням). Нижче найпоширеніші:
              </p>
              <ul class="main-page-list">
                <li>
                  <strong>Бульбашкове сортування</strong> (Bubble Sort):
                  послідовно порівнюємо сусідні елементи й міняємо місцями, поки
                  всі не будуть відсортовані. Часова складність:
                  <strong>O(n^2)</strong>.
                </li>
                <li>
                  <strong>Сортування вставками</strong> (Insertion Sort):
                  &laquo;Вставляємо&raquo; елементи у відповідне місце серед уже
                  відсортованих. Часова складність у гіршому випадку: O(n^2).
                  При невеликих наборах даних показує непогану продуктивність.
                </li>
                <li>
                  <strong>Швидке сортування</strong> (Quick Sort): підхід
                  &laquo;розділяй і володарюй&raquo;: обираємо опорний елемент
                  (pivot), розподіляємо менші/більші в різні підмасиви і
                  рекурсивно повторюємо. У середньому: O(n log n), у гіршому
                  разі: O(n^2).
                </li>
              </ul>
              <p class="main-page-descr">
                Кожен з цих алгоритмів має свої &laquo;сценарії&raquo;
                використання. Bubble Sort зазвичай наводять як ілюстрацію
                найпростішого алгоритму, але на практиці майже не застосовують
                через низьку ефективність. Insertion Sort може бути дуже
                зручним, якщо дані вже майже відсортовані, а Quick Sort —
                найпопулярніший у багатьох стандартних бібліотеках мов
                програмування. Вибір алгоритму сортування залежить від того,
                наскільки часто дані треба додавати, якого вони розміру, та від
                особливостей апаратури.
              </p>

              <h3 class="main-page-subsubtitle">Інші алгоритми</h3>
              <p class="main-page-descr">
                Існує багато видів сортувань — наприклад,
                <strong>сортування злиттям</strong> (Merge Sort) із часовою
                складністю O(n log n),
                <strong>сортування вибором</strong> (Selection Sort) з O(n^2)
                тощо. Кожен алгоритм має свої переваги та недоліки; вибір
                залежить від конкретних умов, обсягів даних та потреб у швидкому
                внесенні змін до структури.
              </p>
              <p class="main-page-descr">
                Деякі алгоритми сортування, як-от <em>Merge Sort</em> або
                <em>Heap Sort</em>, можуть давати стабільно гарний час
                виконання, а <em>Shell Sort</em> або
                <em>Counting Sort</em> підходять для специфічних ситуацій.
                Розуміння кількох алгоритмів сортування допомагає обирати саме
                той, що найкраще відповідає вашим потребам за швидкодією та
                складністю реалізації.
              </p>

              <h2 class="main-page-subsubtitle">Алгоритми пошуку в графах</h2>
              <p class="main-page-descr">
                Для обробки графів (вершини + ребра) часто використовують BFS і
                DFS. Граф — це структура, де вузли (вершини) можуть бути
                з'єднані ребрами, котрі мають або не мають ваги. Алгоритми
                дозволяють обходити цей граф, шукаючи шляхи, цикли чи певні
                властивості.
              </p>
              <p class="main-page-descr">
                У залежності від завдання, можна застосовувати той чи інший
                метод. DFS (пошук у глибину) краще підходить, коли нам треба
                дістатися найбільш віддалених вершин, а BFS (пошук у ширину) —
                коли ми шукаємо найкоротший маршрут у рівномірному середовищі.
                Проте обидва працюють з принципово різними структурами даних
                (DFS зазвичай зі стеком, BFS — із чергою).
              </p>

              <h3 class="main-page-subsubtitle">Пошук у ширину (BFS)</h3>
              <p class="main-page-descr">
                <strong>BFS (Breadth-First Search)</strong> — алгоритм обходу
                графа або дерева &laquo;вшир&raquo;, починаючи з початкової
                вершини та відвідуючи всіх сусідів, а потім сусідів сусідів і т.
                д. Зазвичай використовує структуру даних <strong>черга</strong>.
                BFS дозволяє знайти <em>найкоротший шлях</em> у невагомому графі
                (де всі ребра рівної &laquo;вартості&raquo;). Він широко
                використовується в соцмережах, іграх та будь-де, де потрібно
                визначити &laquo;шари&raquo; відстані від початкового вузла.
              </p>
              <p class="main-page-descr">
                Ідея BFS досить проста: ми додаємо у чергу початкову вершину,
                потім послідовно &laquo;витягаємо&raquo; вершини із черги й
                додаємо у неї всіх &laquo;дітей&raquo; цих вершин. Саме тому під
                час виконання BFS ви спершу отримуєте вузли, що розташовані на
                відстані 1, потім 2, 3 і так далі. Цим пояснюється можливість
                знайти найкоротший шлях за умови однакових &laquo;ваг&raquo;
                ребер.
              </p>

              <h2 class="main-page-subsubtitle">
                Алгоритм Дейкстри (Dijkstra)
              </h2>
              <p class="main-page-descr">
                <strong>Дейкстра</strong> використовується для пошуку
                найкоротшого шляху в зважених графах (де кожне ребро має
                &laquo;вагу&raquo;). Він крок за кроком обирає вершину з
                найменшою відстанню від старту, обробляє сусідів, оновлюючи їхні
                відстані, і рухається далі. Так можна визначити найкоротший шлях
                від заданої вершини до всіх інших. Це дуже актуально для задач
                маршрутизації, планування перевезень тощо.
              </p>
              <p class="main-page-descr">
                Уявіть собі карту доріг, де &laquo;вагою&raquo; є кілометри чи
                час у дорозі. Алгоритм Дейкстри допоможе знайти найвигідніший
                маршрут із точки A в точку B. Він також широко використовується
                в мережевих протоколах для вибору &laquo;найкращого&raquo; шляху
                проходження пакетів даних. Обмеження: ребра не повинні мати
                від’ємної ваги, інакше алгоритм не спрацює коректно (для цього
                існують інші методи, як-от Беллмана-Форда).
              </p>

              <h2 class="main-page-subsubtitle">
                Алгоритми у повсякденному житті
              </h2>
              <p class="main-page-descr">
                Щодня ви стикаєтеся з алгоритмами, хоч і не помічаєте. Google
                використовує складні алгоритми пошуку, банківські системи —
                алгоритми безпеки, навігація GPS — алгоритми пошуку найкоротших
                маршрутів. Усе це — приклади застосування алгоритмів у реальному
                житті. Навіть коли ви обираєте оптимальний маршрут додому,
                &laquo;у голові&raquo; виконується щось на кшталт алгоритму:
                оцінка відстані, заторів, часу виїзду тощо.
              </p>
              <p class="main-page-descr">
                Алгоритми також лежать в основі таких речей, як шифрування
                даних, стискання файлів (наприклад, ZIP), обробка графіки,
                штучний інтелект та багато іншого. Тому, навіть якщо ви не
                збираєтеся працювати виключно над алгоритмічними задачами,
                базове розуміння основних алгоритмів суттєво розширить ваш
                кругозір і покращить загальний рівень навичок у програмуванні.
              </p>

              <h2 class="main-page-subsubtitle">Підсумок</h2>
              <p class="main-page-descr">
                Отже, <strong>алгоритми</strong> — це серце програмування.
                Розуміння базових алгоритмів пошуку (лінійного, бінарного),
                сортування (бульбашкового, швидкого), структур даних (стека,
                черги) та <em>часової складності</em> дає вам можливість
                створювати ефективний код і масштабовані програми. Навчання
                алгоритмів робить вас не просто &laquo;кодером&raquo;, а
                розробником, який розуміє <em>як і чому</em>
                все працює.
              </p>
              <p class="main-page-descr">
                Для успішної реалізації великих програм варто не лише знати
                теорію, а й вміти комбінувати алгоритми між собою, оптимізувати
                їх під конкретні умови й навіть створювати власні. Саме тому
                вивчення алгоритмів — ключ до розв’язання завдань високого рівня
                складності й створення гнучких, масштабованих рішень. Вивчайте
                приклади з практики, проводьте власні експерименти з різними
                структурами даних і не припиняйте ставити запитання &laquo;А
                чому це працює саме так?&raquo;. Це неодмінно підніме ваші
                навички та допоможе краще розуміти, яким чином побудовано
                сучасне програмне забезпечення.
              </p>
            </div>
          </div>

          <!-- Кнопка для запуску тесту -->
          <button class="main-page-btn" id="go-to-algorithms-test">
            Перевір вивчене!
          </button>
        </div>
      </div>
    </section>

    <!-- Модальне вікно з тестом на алгоритми -->
    <div id="test-modal-algorithms" class="modal">
      <div class="modal-content">
        <span id="close-modal-algorithms" class="close-btn">&times;</span>
        <h2>Тест на знання Алгоритмів</h2>
        <div id="test-questions-algorithms"></div>
        <div id="test-result-algorithms" style="display: none"></div>
        <button id="submit-test-algorithms" class="main-page-btn">
          Завершити тест
        </button>
        <button
          id="retry-test-algorithms"
          class="main-page-btn"
          style="display: none"
        >
          Пройти тест знову
        </button>
      </div>
    </div>

    <!-- Модальне вікно реєстрації -->
    <div id="registration-modal" class="modal">
      <div class="modal-content">
        <span id="close-registration-modal" class="close-btn">&times;</span>
        <h2 id="auth-modal-title">Реєстрація</h2>
        <form id="registration-form">
          <div id="name-field">
            <label for="name">Ім'я:</label>
            <input type="text" id="name" name="name" required />
          </div>
          <label for="email">Email:</label>
          <input type="email" id="email" name="email" required />
          <label for="password">Пароль:</label>
          <input type="password" id="password" name="password" required />
          <button type="submit" class="main-page-btn">Зареєструватися</button>
        </form>
        <p id="switch-to-login">
          Вже маєте аккаунт? <a href="#" id="to-login-link">Увійти</a>
        </p>
      </div>
    </div>

    <!-- Модальне вікно профілю -->
    <div id="profile-modal" class="modal">
      <div class="modal-content">
        <span id="close-profile-modal" class="close-btn">&times;</span>
        <h2>Ваш профіль</h2>
        <form id="profile-form">
          <img
            id="profile-photo"
            src=""
            alt="Фото профілю"
            style="
              width: 150px;
              height: 150px;
              object-fit: cover;
              display: block;
              margin-bottom: 15px;
            "
          />
          <label for="uploadPicture">Ваше фото:</label>
          <input type="file" id="uploadPicture" name="profilePhoto" />
          <p>Ім'я: <span id="user-name"></span></p>
          <p>Email: <span id="user-email"></span></p>
          <label for="aboutMe">Про себе:</label>
          <textarea id="aboutMe" placeholder="Напишіть про себе..."></textarea>
          <button type="submit" class="main-page-btn">Зберегти</button>
        </form>
        <div id="user-results">
          <h3>Ваші результати тестів:</h3>
          <ul id="results-list"></ul>
        </div>
        <button id="logout-button" class="main-page-btn">Вийти</button>
      </div>
    </div>

    <button id="scrollToTopBtn" class="scroll-to-top">/\</button>

    <footer>
      <p>
        Проект створив Білик Володимир Сергійович, студент Технічного коледжу
        ТНТУ ім. І. Пулюя. Всі права захищено © 2024
      </p>
      <div class="social-media">
        <a href="https://www.facebook.com" target="_blank"
          ><img
            src="img/facebook-icon-white.png"
            alt="Facebook"
            class="social-icon"
        /></a>
        <a href="https://www.twitter.com" target="_blank"
          ><img
            src="img/twitter-icon-white.png"
            alt="Twitter"
            class="social-icon"
        /></a>
      </div>
    </footer>

    <!-- Скрипт оф-канвасу -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const menuIcon = document.getElementById("menu-icon");
        const offcanvasMenu = document.getElementById("offcanvas-menu");
        const closeMenuBtn = document.getElementById("close-menu");

        menuIcon.addEventListener("click", () => {
          offcanvasMenu.classList.add("open");
        });

        closeMenuBtn.addEventListener("click", () => {
          offcanvasMenu.classList.remove("open");
        });

        document.addEventListener("click", (e) => {
          if (
            !offcanvasMenu.contains(e.target) &&
            !menuIcon.contains(e.target)
          ) {
            offcanvasMenu.classList.remove("open");
          }
        });
      });
    </script>
  </body>
</html>
